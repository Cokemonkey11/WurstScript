package Knockback3
    import Terrain
    import MapBounds
    import LinkedList

    public class Knockback3
        // Fraction of velocity retained after colliding with
        // ground/destructable.
        static var restitutionCoefficientGround       = .2
        static var restitutionCoefficientDestructable = .3

        // Ratio.
        static var frictionCoefficientGround = .15

        // In units per second squared.
        static var gravity = 90.

        // If a unit is not falling faster than this, it will not bounce. Units
        // per second.
        static var elasticityThreshold = -300.

        // If a unit's vertical component is not greater than this, it will not
        // become airborne. Units per second.
        static var airborneThreshold = 150.

        // For the purposes of friction, distinguish a unit which is airborne
        // versus one which is sliding. Height in units.
        static var isAirborneThreshold = 5.

        // Below this speed, slighting units will stop.
        static var minimumSlideSpeed = 30.

        // Above this speed, sliding units will spawn a dust effect.
        static var frictionFxThreshold = 180.
        static var frictionFxPath = "Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"

        // Above this speed, destructables hit will be destroyed.
        static var destroyDestructableSpeedThreshold = 300.

        // Below this height, destructables hit may be destroyed.
        static var destroyDestructableHeightThreshold = 150.

        // The square rect size used for finding destructables.
        @configurable static constant real DESTRUCTABLE_ENUM_SIZE = 130.

        // If enabled, units have their move-speed changed while airborne.
        // Warning: this is not a lock-safe form of crowd control.
        @configurable static constant bool USE_MOVE_SPEED_MODIFIERS  = true

        // If enabled, units have their prop window changed while airborne.
        // Warning: this is not a lock-safe form of crowd control.
        @configurable static constant bool USE_PROP_WINDOW_MODIFIERS = true


        // Instance Variables
        private unit u
        private vec3 del


        private static bool     hitDestructable
        private static function destructableCallback()
            let des = GetEnumDestructable()
            if GetDestructableLife(des) > 0.
                hitDestructable = true


        private   static constant       knockbacks       = new LinkedList<Knockback3>()
        private   static timer          clock            = CreateTimer()
        private   static constant       unitNodes        = new Table()
        protected static rect           destructableRect = Rect(-1*Knockback3.DESTRUCTABLE_ENUM_SIZE, -1*Knockback3.DESTRUCTABLE_ENUM_SIZE, Knockback3.DESTRUCTABLE_ENUM_SIZE, Knockback3.DESTRUCTABLE_ENUM_SIZE)
        protected static function       tick()
            let iter = knockbacks.iterator()
            while iter.hasNext()
                let knockback = iter.next()
                let unitX     = knockback.u.getX()
                let unitY     = knockback.u.getY()
                let flyHeight = knockback.u.getFlyHeight()
                let newX      = unitX + knockback.del.x
                let newY      = unitY + knockback.del.y

                let newInMap = vec2(newX, newY).inPlayable()

                let velXySquared = knockback.del.x*knockback.del.x + knockback.del.y*knockback.del.y

                if flyHeight < isAirborneThreshold
                    if isTerrainWalkable(newX, newY) and newInMap
                        knockback.u..setX(newX)..setY(newY)

                        if knockback.del.z <= isAirborneThreshold
                            knockback.del.x = knockback.del.x*(1. - frictionCoefficientGround)
                            knockback.del.y = knockback.del.y*(1. - frictionCoefficientGround)

                            if velXySquared > frictionFxThreshold*ANIMATION_PERIOD
                                AddSpecialEffect(frictionFxPath, unitX, unitY).destr()

                        if USE_MOVE_SPEED_MODIFIERS
                            knockback.u.setMoveSpeed(GetUnitDefaultMoveSpeed(knockback.u))

                        if USE_PROP_WINDOW_MODIFIERS
                            knockback.u.setPropWindow(GetUnitDefaultPropWindow(knockback.u) * bj_DEGTORAD)

                    else
                        knockback.del.x = 0
                        knockback.del.y = 0

                    if knockback.del.z < elasticityThreshold*ANIMATION_PERIOD
                        knockback.del.z = knockback.del.z*-1.*restitutionCoefficientGround

                    if knockback.del.z > airborneThreshold*ANIMATION_PERIOD
                        knockback.u.setFlyHeight(flyHeight + knockback.del.z, 0.)
                        knockback.del.z = knockback.del.z - gravity*ANIMATION_PERIOD
                else if newInMap
                    knockback.del.z = knockback.del.z - gravity*ANIMATION_PERIOD
                    let heightDifference = getTerrainZ(newX, newY) - getTerrainZ(unitX, unitY)

                    knockback.u..setFlyHeight(flyHeight + knockback.del.z - heightDifference, 0.)
                          ..setX(newX)..setY(newY)

                    if USE_MOVE_SPEED_MODIFIERS
                        knockback.u.setMoveSpeed(0.)

                    if USE_PROP_WINDOW_MODIFIERS
                        knockback.u.setPropWindow(0.)

                if velXySquared < minimumSlideSpeed*ANIMATION_PERIOD and knockback.del.z > elasticityThreshold*ANIMATION_PERIOD and knockback.del.z < -1*elasticityThreshold*ANIMATION_PERIOD and flyHeight < isAirborneThreshold
                    knockback.u.setFlyHeight(0., 0.)
                    unitNodes.removeInt(knockback.u.getHandleId())

                    if USE_MOVE_SPEED_MODIFIERS
                        knockback.u.setMoveSpeed(GetUnitDefaultMoveSpeed(knockback.u))

                    if USE_PROP_WINDOW_MODIFIERS
                        knockback.u.setPropWindow(GetUnitDefaultPropWindow(knockback.u) * bj_DEGTORAD)

                    iter.remove()

                if velXySquared > destroyDestructableSpeedThreshold*ANIMATION_PERIOD and flyHeight < destroyDestructableHeightThreshold
                    hitDestructable = false
                    MoveRectTo(destructableRect, newX, newY)
                    EnumDestructablesInRect(destructableRect, null, function destructableCallback)

                    if hitDestructable
                        knockback.del.x = knockback.del.x*restitutionCoefficientDestructable
                        knockback.del.y = knockback.del.y*restitutionCoefficientDestructable
            iter.close()

            if knockbacks.getSize() == 0
                clock.pause()


        // Apply a knockback vector to unit u. Velocity is in units per second.
        // Angle refers to the angle on the XY plane, in radians. Alhpa refers
        // to the launch trajectory, in radians, where 0 is flat along the XY
        // plane.
        private static constant int ID_CROW_FORM = 'Arav'
        static function add(unit u, real velocity, real angle, real alpha)
            let instVel = velocity*ANIMATION_PERIOD

            Knockback3 knockback
            if unitNodes.hasInt(u.getHandleId())
                knockback       = unitNodes.loadInt(u.getHandleId()) castTo Knockback3
                knockback.del.x = knockback.del.x + instVel*Cos(angle)*Cos(alpha)
                knockback.del.y = knockback.del.y + instVel*Sin(angle)*Cos(alpha)
                knockback.del.z = knockback.del.z + instVel*Sin(alpha)
            else
                knockback     = new Knockback3()
                knockback.u   = u
                knockback.del = vec3(instVel*Cos(angle)*Cos(alpha), instVel*Sin(angle)*Cos(alpha), instVel*Sin(alpha))

                knockbacks.add(knockback)
                if knockbacks.getSize() == 1
                    clock.startPeriodic(ANIMATION_PERIOD, function tick)

                if knockback.u.addAbility(ID_CROW_FORM)
                    knockback.u.removeAbility(ID_CROW_FORM)


        static function setVel(unit u, real velocity, real angle, real alpha)
            let handleId = u.getHandleId()
            if unitNodes.hasInt(handleId)
                let knockback = unitNodes.loadInt(handleId) castTo Knockback3
                let instVel   = velocity*ANIMATION_PERIOD

                knockback.del = vec3(instVel*Cos(angle)*Cos(alpha), instVel*Sin(angle)*Cos(alpha), instVel*Sin(alpha))
            else
                add(u, velocity, angle, alpha)


        static function getVel(unit u) returns real
            var v = 0.
            let handleId = u.getHandleId()
            if unitNodes.hasInt(handleId)
                let knockback = unitNodes.loadInt(handleId) castTo Knockback3
                v             = knockback.del.length()

            return v
